# 14장. 전역변수의 문제점

## 14.1 변수의 생명주기

### (1) 지역변수의 생명 주기

변수는 선언에 의해 생성되고 할당을 통해 값을 가지면서 언젠가 소멸되는 생명주기를 가진다. 변수에 생명주기가 없다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다.
```js
function foo() {
  var x = 'local';
  console.log(x); // local
  return x;
}

foo();
console.log(x);  // ReferenceError: x is not defined
```
    지역변수x는 foo 함수가 호출되기 전까지는 생성되지 않는다.
    foo함수를 호출하지 않으면 함수 내부 변수 선언문이 실행되지 않기 때문이다.


전역 변수의 선언은 위치에 상관없이 런타임 이전에 가장 먼저 실행되고, 함수 내부에서 선언한 변수는 함수가 호출된 직후 함수 몸체의 코드가 한 줄 씩 순차적으로 실행되기 이전에 JS엔진에 의해 먼저 실행된다.


<p align="center"><img src="https://velog.velcdn.com/images%2Fdev_jazziron%2Fpost%2F4447f2a0-fed3-4e19-98c9-506ee079c660%2Fimage.png" width="450px"></p>

    foo() 호출하면 함수 몸체의 다른 문들이 순차적으로 실행되기 이전에
    x 변수의 선언문이 JS엔진에 의해 가장 먼저 실행되어 x 변수가 선언되고 undefined로 초기화된다.
    그 후, 함수 몸체를 구성하는 문들이 순차적으로 실행되기 시작하고 변수 할당문이 실행되면 x 변수에 값이 할당된다.
    함수가 종료하면 x 변수도 소멸되어 생명주기가 종료된다.
    따라서 함수 내부에서 선언된 지역 변수 x 는 foo 함수가 호출되어 실행되는 동안에만 유효하다.

*즉, 지역변수의 생명주기는 함수의 생명주기와 일치한다.*

변수의 생명주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용메모리 풀(Memory pool)에 반환되는 시점까지이다.

변수는 자신이 등록된 스코프가 소멸될 때 까지 유효하다. 할당된 메모리 공간은 더이상 참조하지 않을 때 가비지콜렉터에 의해 해제되어 가용메모리풀에 반환되어 메모리 공간을 참조하고 있으면 해제되지않고 확보된 상태로 남아있게 되는 것이다.


<br>

```js
var x = 'global';

function foo() {
  console.log(x);     // global (x)  undefined (o)
  var x = 'local';
}

foo();
console.log(x);
```
    foo 함수 내부에서 선언된 지역변수 x 는 console.lgo(x) 시점에 이미 선언되었고 undefined로 초기화된 상태

이처럼 **호이스팅은 스코프 단위로 동작**한다. 전역변수는 전역 전체에서, 지역변수는 함수 전체에서 유효하다.

### (2) 전역변수의 생명 주기

<p align="center"><img src="https://velog.velcdn.com/images/kozel/post/174cf156-024b-4b68-b89e-4ec7393c8cbc/image.jpeg" width="450px"></p>

var 키워드로 선언한 전역변수는 전역객체의 프로퍼티가 된다. 따라서 var 키워드로 선언된 전역 변수는 브라우저 환경에서 `전역객체 window`의 프로퍼티가 되는 것이므로 `전역 객체 window`는 웹 페이지를 닫을 때까지 유효하며 var 키워드로 선언한 전역 변수의 생명주기는 전역 객체의 생명 주기와 일치하게 된다.

## 14.2 전역 변수의 문제점
1. 어디서는 참조하고 할당할 수 있기때문에 **암묵적 결합을 허용**하여 의도치 않은 상태 변경을 유발할 수 있다
2. **생명주기가 길어** 메모리 리소스도 오랜 기간 소비하며 중복 선언이 허용되어 의도치 않은 재할당이 발생할 수 있다
3. **스코프 체인상 종점에 존재**해 전역 변수의 검색속도가 가장 느리다
4. 파일이 분리되어도 하나의 전역 스코프를 공유하므로 전역 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있어 **네임스페이스 오염** 발생이 크다


## 14.3 전역 변수의 사용을 억제하는 방법

### (1) 즉시 실행 함수
```js
(function() {
  var foo = 10;
  // ...
}());

console.log(foo);	// ReferenceError: foo is not defined
```
즉시실행함수로 감싸면 변수는 즉시실행함수의 지역변수가 되므로 전역변수 사용을 제한할 수 있다.

### (2) [네임스페이스](https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%A6%84%EA%B3%B5%EA%B0%84) 객체

**네임스페이스**란, 개체를 구분할 수 있는 말로 단 하나의 개체만을 가리킨다.


```js
var MYAPP = {};	// 전역 네임스페이스 객체

MYAPP.name = 'Kozel';

console.log(MYAPP.name); // Kozel
```
전역에 네임스페이스 역할을 담당할 객체를 생성한 뒤 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하여 전역 변수의 사용을 제한 할 수 있다.

```js
var MYAPP = {};	// 전역 네임스페이스 객체

MYAPP.person = {
  name: 'Kozel',
  address: 'Seoul'
};

console.log(MYAPP.person.name); // Kozel
```
네임스페이스 객체에 다른 네임스페이스객체를 프로퍼티로 추가해 계층적으로 구성할 수 도 있다. 네임스페이스를 분리하여 식별자 충돌을 방지할 수는 있으나 이 객체 자체가 전역 변수에 할당되므로 유용한 방법은 아니다.

### (3) 모듈패턴
모듈패턴은 클래스를 모방하여 관련있는 변수와 함수를 모아 즉시실행함수로 감싸 하나의 모듈을 생성하는 방법이다. 이 패턴은 클로저를 기반으로 동작하여 전역 변수의 억제는 물론 캡슐화까지 구현가능하다.

```js
var Counter = (function() {
  // private 변수 -> 정보은닉
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase(){
      return ++num;
    },
    decrease(){
      return --num;
    }
  };
}());

console.log(Counter.num);	// undefined 외부로 노출되지 않는다.
console.log(Counter.increase());	// 1
console.log(Counter.decrease());	// 0
```
    위의 즉시실행함수는외부에 노출하고 싶은 변수나 함수같은 객체를 담아 반환한다.
    이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버(public member)이고,
    반환하는 객체에 추가하지 않은 변수나 함수는 프라이빗 멤버(private member)가 된다.

**캡슐화**란, 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다. 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하는데 이를 **정보은닉**이라한다.


### (4) ES6 모듈

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공하기때문에 var 키워드로 선언한 변수는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.

```js
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```
es6모듈사용시 script 태그에 type="module" 어트리뷰트를 추가하고 모듈 파일의 확장자를 mjs로 사용하면 로드된 JS 파일은 모듈로서 동작한다.